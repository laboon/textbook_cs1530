## Introduction

People often think of software engineering as programming.  They then enroll in Computer Science classes to learn how to program.  Sadly, this causes many people to conflate the terms _software development_, _programming_, and _computer science_, when the terms have very different meanings.

Computer Science is the base upon which all computational activity rests.  It focuses on the theory of computation, algorithms, and automation in general.  Although having a computer can often give us insights into computer science, in theory there is no need for a computer scientist to have access to a computer at all!  Early researchers such as Alan Turing and Ada Lovelace did important computational work well before they ever touched a working computer.  As a famous quote often attributed to Edsger Dijkstra goes, "computer science is no more about computers than astronomy is about telescopes."  That is, computers can be tools to help us understand computation, but they are the means, not an ends.

Programming is simply telling the computers what to do - writing a sequence of instructions that the computer can execute, in a way that the computer can udnerstand it.  You can and should use your understanding of computer science to help you in programming.  For example, understanding the difference between a bubble sort and an insertion sort is the realm of computer science.  You very easily could think about different ways to sort without ever touching a keyboard (for example, sorting a deck of cards).  Translating the mathematical abstraction of sorting into a specific set of instructions for the computer would be programming.

Software engineering builds on top of programming to create actual software systems.  Besides just telling the computer what to do, we need to organize our system so that it can be improved upon, by us and others.  We need to determine if the software is working correctly, by testing it.  We need to come up with ways to distribute and/or deploy it.  We need to think of how to organize interfaces, both internally between subsystems and externally with the outside world.  We need to be able to develop something that the customers and users want, and modify our system when we determine that there is a defect or just something that the users did not want.  Although much of this work rests on programming, there is much more to it than that!

As an analogy, think of a large bridge.  A group of civil engineers designed the bridge, ensured that it met regulatory standards, determined how to test its strength, and other high-level activities.  What they are doing can be thought of as the equivalent of software engineering.  Construction workers actually put the pieces into place, poured the concrete, and welded everything together.  This is the equivalent of programming.  However, for any of this to work, physicists and material science researchers worked hard to determine what kind of concrete would handle the load, how much stress a suspension cable can take, and models of how wind impacts a structure.  This is the equivalent of computer science.  

In our bridge example, civil engineers require construction workers and physicists.  Even if engineers don't know as much about, say, oxidation as a physicist might, they can take the information and use it to mitigate rusting of their structures.  They may not know all of the techniques of underwater welding that a specialized worker does, but they know when it is necessary and the limitations of it.  Similarly, software developers require knowing how to program and the basics of computer science.  Even if what they work on is mostly working at a higher level, a knowledge of the basics is necessary.  For example, most software developers have never written their own hash map data structure to be used in a commercial product.  However, most will have to know, at some point, the benefits and drawbacks of using a hash map compared to an array or binary tree.

In this book, the focus is on learning how to create and design the bridge - or software product.  Although programming and computer science are important aspects of this, there are many more issues to deal with when creating a software system.  How do we determine what the user wants the system to do?  How do we then design a system to do that?  How can it be maintained?  How can we prioritize what features to add?  How can we work with a large number of people?  How do we integrate our particular subsystems or pieces of functionality with others?  Many of these questions are ignored, or at least put off, when learning to program.  However, they often form the bulk of what a software developer does.

